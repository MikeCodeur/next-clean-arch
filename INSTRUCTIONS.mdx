# Validations Layers

### ğŸ’¡ Description longue de l'exercice

## ğŸ“ Tes notes

Detaille ce que tu as appris ici,Â surÂ uneÂ pageÂ [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

La validation des donnÃ©es est une Ã©tape essentielle dans toute application bien structurÃ©e, car elle garantit l'intÃ©gritÃ© des informations qui circulent entre les diffÃ©rentes couches du systÃ¨me.

Que ce soit pour valider les entrÃ©es utilisateur dans l'interface, appliquer des rÃ¨gles mÃ©tier complexes au niveau des services, ou assurer la conformitÃ© des donnÃ©es avec les contraintes de la base de donnÃ©es, chaque niveau a des besoins spÃ©cifiques.

Une validation bien pensÃ©e repose sur un principe clÃ© : l'isolation des responsabilitÃ©s. En segmentant les validations par couche â€” prÃ©sentation, service, persistance â€” on s'assure non seulement de la cohÃ©rence des donnÃ©es mais aussi de la maintenabilitÃ© du code.

Cette approche permet d'Ã©viter les erreurs courantes, comme la rÃ©utilisation abusive d'un mÃªme modÃ¨le de validation dans tous les contextes, et offre une base solide pour construire des applications Ã©volutives et fiables.

âš ï¸ Un `formulaire`, un `service` et une `table` en base de donnÃ©es nâ€™ont pas toujours la mÃªme forme. Lâ€™erreur courante et dâ€™utiliser le mÃªme validateur pour toutes les couches.

Par exemple nous avons la validation au niveau du `formulaire` de produit `createEditProductFormSchema`

```tsx
//product-form-validation.ts
//action.ts
export async function onSubmitAction(
  prevState: FormState,
  data: FormData
): Promise<FormState> {
  const formData = Object.fromEntries(data)
  const parsed = createEditProductFormSchema.safeParse(formData)

  if (!parsed.success) {
```

On pourrait rÃ©utiliser `createEditProductFormSchema` au niveau du service.

```tsx
//product-service.ts
export async function createProductService(data: AddProduct) {
  const parsed = createEditProductFormSchema.safeParse(data)
  if (!parsed.success) {
    throw new Error(`Validation failed ${parsed.error.message}`)
  }
  return productRepository.createProductDao(data)
}
```

âš ï¸ En faisant cela on introduit des dÃ©pendances entre le `service` et la `prÃ©sentation` et câ€™est ce que nous souhaitons Ã©viter

âœ… La rÃ¨gle suivante nous interdit dâ€™importer des modules de `app` (prÃ©sentation) vers `service` et `persistance`

```tsx
{
    files: ['src/db/**/*.ts', 'src/services/**/*.ts'],
    rules: {
      'no-restricted-imports': [
        'error',
        {
          patterns: ['@/app/*'],
        },
      ],
    },
  },
```

Il faut donc avoir des `validateurs` pour la `prÃ©sentation` (les formulaires gÃ©nÃ©ralement) et les autres couches (`service` et Ã©ventuellement `persistance`)

Il serait possible dâ€™avoir

- un rÃ©pertoire `validation` dans la `prÃ©sentation`
- un rÃ©pertoire `validation` dans le `service`
- un rÃ©pertoire `validation` dans la `persistance`

Mais nous ferons le choix de tout centraliser dans un `service de validation` au niveau `service`

```tsx
/src
  /services
    /validation
      validation-form.ts
      validate-service.ts
      validation-peristence.ts
```

Pour simplifier la suite des exercices, nous avons dÃ©placÃ© tous les schÃ©mas `zod` dans ces dossiers la.

## Exercice

Pour illustrer a quelle point câ€™est important dâ€™avoir une isolation entre le schÃ©ma `zod` de validation proche de la base de donnÃ©es et les formulaires. Nous allons crÃ©er une fonctionnalitÃ© : â€œAjout Rapide de produitâ€ .

### RÃ¨gles de cette fonctionnalitÃ©

2 champs disponibles (`Nom` de produit et `nom` de la catÃ©gorie)

- Si la catÃ©gorie existe, on la crÃ©e Ã  la volÃ©, sinon on la rÃ©cupÃ¨re
- On crÃ©Ã© ensuite le produit associÃ© a la catÃ©gorie

Pour gagner du temps le formulaire est dÃ©jÃ  accessible : [http://localhost:3000/shop-admin/quick](http://localhost:3000/shop-admin/quick) Il est connectÃ© au serveur action `shop-admin/actions.ts`

```tsx
//shop-admin/actions.ts
export async function quickAddProduct(
  prevState: FormState,
  data: FormData
): Promise<FormState> {
  const formData = Object.fromEntries(data)
  const parsed = quickAddProductFormSchema.safeParse(formData)
  if (!parsed.success) {
    logZodError(data)
    return {
      success: false,
      message: `Erreur de validation`,
    }
  }
  const product = await createProductWithCategoryService(
    parsed.data.productName,
    parsed.data.categoryName
  )
  revalidatePath('/shop-admin')

  return {
    success: true,
    message: `SauvegardÃ© avec success ${product.title}`,
  }
}
```

Et le schÃ©ma `zod`

```tsx
//services/validation/ui/product-form-validation.ts
export const quickAddProductFormSchema = z.object({
  productName: z.string().min(2, {
    message: 'Title must be at least 2 characters.',
  }),
  categoryName: z.string().min(2, {
    message: 'Description must be at least 2 characters.',
  }),
})
```

CotÃ© prÃ©sentation tu nâ€™as rien Ã  faire

ğŸ¶ Dans le `product-service` tu vas devoir implÃ©menter deux fonctions :

- `getOrCreateCategoryService` : Fonction qui va soit rÃ©cupÃ©rer ou crÃ©er une catÃ©gorie en fonction du nom, utilise `labelShema` pour la validation du nom
- `createProductWithCategoryService` : Fonction qui va valider les donnÃ©es (utilise `labelShema` ), qui va appeler `getOrCreateCategoryService` et crÃ©er le produit avec la catÃ©gorie

Constate la validation du formulaire et la validation de donnÃ©es cotÃ© service. Les deux sont maintenant clairement isolÃ©s.

Fichiers

- `services/product-service.ts`
- `services/validation/validation-service.ts`

## Bonus

### 1. ğŸš€ Validation complet du service

Les donnÃ©es en entrÃ©es de services doivent Ãªtre validÃ©es. Nous avons donc des schÃ©mas `zod` dans `validation-service.ts`

Valide les donnÃ©es avec `createEditProductSchema` sur

- `createProductService`
- `persistProductService`

Fichiers

- `services/product-service.ts`
- `services/validation/validation-service.ts`

### 2. ğŸš€ Sanitize

La validation de donnÃ©es avec `zod ,` va valider les champs mais cela ne va pas valider les champs supplÃ©mentaires, par exemple :

```tsx
const schema = z.object({
  name: z.string(),
  age: z.number(),
});

const data = {
  name: "Alice",
  age: 25,
  extraField: "not allowed", // Champ supplÃ©mentaire
};
const parsed = schema.safeParse(data); // OK
```

De plus les donnÃ©es peuvent Ãªtre valides mais mal formattÃ©s â€¦ Zod possÃ¨de Ã©galement des fonctions de conversions comme `trim()`

```tsx
const financeSchema = z.object({
  amount: z.string().transform((val) => parseFloat(val)), // Convertir une chaÃ®ne en nombre
  description: z.string().trim().optional(), // Supprimer les espaces inutiles
});

// Exemple de donnÃ©es d'entrÃ©e
const rawData = {
  amount: "  123.45 ",
  description: "  Achat de matÃ©riel   ",
};
const parsed = financeSchema.safeParse(rawData);
const financeParamsSanitized = parsed.data;
// RÃ©sultat : { amount: "  123.45 ", description: "  Achat de matÃ©riel
```

Pour avoir les donnÃ©es saines il est possible d'utiliser `parsed.data`.

- **ğŸ¶Utilise les donnÃ©es `â€œsanitizedâ€` dans les fonctions ou il y a de la validation**

Fichiers

- `services/validation/validation-service.ts`

## Ils vont tâ€™aider

- **ğŸ¶ Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **ğŸ¤– Ash le Robot** : _Ash le Robot te donnera du code utile._
- **ğŸš€ Julia La roquette** : _Julia te donnera des dÃ©fis supplÃ©mentaires._
- **â›ï¸ Hulk le Marteau** : _Quand du code Ã  supprimer est prÃ©sent_
- **ğŸ‘¨â€âœˆï¸ Hugo le chef de projet** : _Va t'aider sur les spÃ©cifications du projet_

## ğŸœ Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20Mastery&entry.1430994900=Clean%20Architecture&entry.533578441=05%20validation).
