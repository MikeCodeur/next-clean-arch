# Les repositories (persistance)

### 💡 Comprendre les repositories

## 📝 Tes notes

Detaille ce que tu as appris ici, sur une page [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Le principe du repository est d'isoler l'accès aux données en créant une couche intermédiaire qui sert d'interface entre la logique métier et la persistance, permettant de manipuler les données sans dépendre directement du détail de l'ORM ou de la base de données.

Pour s’assurer d’une bonne isolation entre la couche de l’ORM et les couches supérieures (service ou, dans notre cas, présentation), nous allons ajouter des règles au niveau du linter. Cela nous permettra d’éviter que la couche de présentation puisse importer directement des éléments liés à l’ORM, comme les schémas ou les fonctions d’accès aux données.

### Le principe d'inversion de dépendance

Pour aller plus loin, ce découplage repose sur le **principe d’inversion de dépendance**, qui fait partie des principes SOLID. Selon ce principe :

1. **Les modules de haut niveau (présentation ou service)** ne doivent pas dépendre des modules de bas niveau (ORM).
2. **Les deux doivent dépendre d’abstractions** (par exemple, des interfaces ou des contrats définis dans la couche repository).
3. **Les détails d’implémentation (ORM)** doivent être dépendants des modules de haut niveau via ces abstractions.

En appliquant ce principe, nous nous assurons que :

- La couche présentation n’a aucune connaissance de la base de données ou des outils spécifiques (Drizzle ORM, Prisma, etc.).
- Toute modification au niveau de la base de données n’impactera pas les couches supérieures.

```tsx
[Présentation] ---> [Service] ---> [Repository] ---> [ORM/DB]
```

### Mise en œuvre technique

### Étape 1 : Création de la règle de linter

Ajoutez une règle à votre fichier `eslint` pour empêcher les imports directs depuis la couche ORM dans la couche présentation. Par exemple :

```tsx
 //eslint.config.mjs
 {
    files: ['src/app/exercices/**/*.{ts,tsx}'],
    rules: {
      'no-restricted-imports': [
        'error',
        {
          patterns: ['@/db/schema/*'],
        },
      ],
    },
  },
```

En ajoutant cette configuration, notre application est en error `no-restricted-imports`, tu peux le constater avec

```tsx
pnpm build
```

Pour simplifier les exercices nous avons regrouper tous les appels aux fonctions qui accèdent à la base de données dans un seul fichier `exercices/data-lib.ts`

- Les `actions.ts` appellent maintenant les fonctions de `exercices/data-lib.ts`

## Exercice

Dans cet exercice tu vas devoir implémenter 2 repositories pour isoler l’ORM du reste de l’application

- Un pour la gestion des `users` en base de données
- Un pour la gestion des `products` en base de données

Dans un repository nous implémentons généralement

- un CRUD
- et des fonctions plus spécifiques

**🐶** Pour cela créé des `CRUD` dans `repository`

**🐶** Pour cela déplace tout le code (ayant des dépendances à `l’orm` ) contenu dans la présentation (`exercices/data-lib.ts`) vers la persistance (`db/repositories/`)

Note : En cas de problème d’importation sur les Types tu peux désactiver la règle (nous verrons ce point dans l’exercice suivant)

```tsx
// eslint-disable-next-line no-restricted-imports
import {UserAddModel} from '@/db/schema/users'
```

Fichiers

- `app/exercises/data-lib.ts`
- `db/repositories/product-repository.ts`
- `db/repositories/user-repository.ts`

## Bonus

### 1. 🚀 Isolation des types du model

Notre ORM (`Drizzle`) nous permet d’avoir des types (typescript) en fonction du model.

Exemple :

```tsx
//src/db/schema/products.ts
export type ProductModel = typeof products.$inferSelect
export type AddProductModel = typeof products.$inferInsert
```

Nous pouvons ensuite utiliser ces types dans les signatures de nos fonctions, comme par exemple

```tsx
export async function createProduct(newProduct: AddProductModel) {
  const [createdProduct] = await db.insert(products) ...
  ...
}
```

Cela ne pose pas de problème dans la couche de persistance. Mais au niveau des couches supérieures (présentation / services) nous ne voulons pas avoir de dépendances avec des types de plus bas niveau. Nous ne voulons pas avoir

```tsx
import {UserAddModel} from '@/db/schema/users'
```

Fichiers

- `app/exercises/data-lib.ts`
- `types/product-types.ts`
- `types/user-types.ts`

### 2. 🚀 Découplage complet

Active la règle `'no-restricted-imports'` sur toute la couche de présentation avec la configuration suivante : `files: ['src/app/**/*.{ts,tsx}'],`

```tsx
// eslint.config.mjs
 {
    files: ['src/app/**/*.{ts,tsx}'],
    //files: ['src/app/exercices/**/*.{ts,tsx}'], //
    rules: {
      'no-restricted-imports': [
        'error',
        {
          patterns: ['@/db/schema/*', '@/db/schema', 'drizzle-orm'],
        },
      ],
    },
  },
```

- **🐶 Fini le découplage en remplaçant tous les types par les types découplés**

exécute : `pnpm build` pour voir les fichiers en error

Fichiers

- `eslint.config.mjs`

## Ils vont t’aider

- **🐶 Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **🤖 Ash le Robot** : _Ash le Robot te donnera du code utile._
- **🚀 Julia La roquette** : _Julia te donnera des défis supplémentaires._
- **⛏️ Hulk le Marteau** : _Quand du code à supprimer est présent_
- **👨‍✈️ Hugo le chef de projet** : _Va t'aider sur les spécifications du projet_

## 🐜 Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis).
